\chapter{Conclusion and Future Work}
\setheader{Conclusion and Future Work}
\label{ch:conclusion}
 
As this thesis is brought to an end, I would like to use these last pages to
reflect not only on the work I did in the last four years, but also on the
many bumps on the road that I did not get to describe in the preceding chapters.
When it comes to reflections, the  performance art piece Rhythm 10, performed by
Marina Abramovi\'c,  one of the greatest Yugoslav artists, comes to my mind. The
themes that it explores such as taking risks and the inevitability of making
mistakes were the root of fears and doubts that I was slowly overcoming over the
last four years. The photograph on the cover of this thesis was taken when it
was first performed, in Edinburgh, in 1973. The instructions for the performance read:

\begin{quote}
    \underline{Preparation} \\[1\jot]
    I place a sheet of white paper on the floor.\\
    I lay 20 knives of different sizes and shapes on the floor.\\
    I place 2 tape recorders with microphones on the floor.
    
    \underline{Performance} \\[1\jot]
    I turn on the first tape recorder.\\
    I take the first knife and stab in between the fingers of my left hand as
    fast as possible.\\
    Every time I cut myself, I change to a different knife. \\
    When I've used all of the knives (all the rhythms), I rewind the tape
    recorder. \\ 
    I listen to the recording of the first part of the performance. \\ I
    concentrate. \\
    I repeat the first part of the performance. \\
    I take the knives in the same order, follow to the same order, follow to the
    same rhythm and cut myself in the same places. \\
    In this performance, the mistakes of time past and time present are
    synchronized.\\
    I rewind the second tape recorder and listen to the double rhythm of the
    knives.\\
    I leave.
\end{quote}

The work described in this thesis
was cyclic: It consists of three phases (three stops as described in
Chapter \ref{ch:intro}), each of which has the same parts: theory (calculus and
algorithms), engineering (implementation), and optimization (heuristics). While
the calculi were mostly developed by Alexander Bentkamp
\cite{bbcw-21-lfho,bbtvw-21-sup-lam,bbtv-21-full-ho-sup}, the task of developing
algorithms for indexing or unification, as well as the tasks of implementing and
optimizing the implementation, were mainly mine.

Structuring the project cyclically turned out to be a great idea of Jasmin
Blanchette. When I first started doing the research which would later form the
basis of Chapter \ref{ch:ehoh}, I was overwhelmed by the scope of the project
and felt uncertain if E could ever fully support $\lambda$-free higher-order
logic. Many of the extensions described in the later chapters were even larger
in scope. However, as each extension relied on the previous one, I quickly
developed a feeling of where the possible pitfalls are and how to avoid them.
This gave me an invaluable source of encouragement, without which I could hardly have
arrived at the end of the project.

The work in Chapter~\ref{ch:ehoh} completed the first cycle. Soon after the
original paper introducing Ehoh \cite{vbss-19-ehoh1} was published, Ehoh found
its use as the backend of Sledgehammer and Satallax, showing that even when
limited to a fragment of higher-order logic, efficient higher-order reasoning is
in demand.

\looseness=-1
The goal of the next cycle was to support $\lambda$-abstraction. When we first
implemented \lsup{}, the calculus that achieves this goal, we quickly realized
that one of its main flaws was that it relies on enumerating full unifiers. In
comparison, some older resolution-based higher-order calculi enumerate
preunifiers, which are less explosive and thus more manageable. This is why we
focused on developing a full unification procedure that removes the redundancy
present in other procedures. It also implements many advancements and
optimizations described in the unification literature after the introduction of
the most influential full unification procedure, Jensen-Pietrzykowski's
procedure in the 1970s. We also made sure that our procedure can easily be
customized to trade bits of its completeness for substantially improved
performance. This procedure, described in Chapter~\ref{ch:unif}, transformed the
\lsup{} calculus into a competitive higher-order calculus.

Even though \lsup{} became competitive, its implementation in Zipperposition
lagged behind the competition. To investigate why this is the case,
we manually analyzed hundreds of benchmarks which the competition proves, but
on which Zipperposition failed. This analysis forms the basis of work that is
described in Chapters \ref{ch:bools} and \ref{ch:ho-techniques}. The main
conclusion was that the competition, most notably the tableaux-based Satallax,
reasons better with formulas. Tableaux inferences are more intuitive than the
ones that superposition or resolution provers perform and are more in line with
how a mathematician structures a proof. Fitting these kind of
inferences into the superposition context was challenging, but it proved very
successful. After they were implemented in Zipperposition, it took its first
victory at the higher-order division of CASC.

After its first victory, Zipperposition was successfully integrated into
Sledgehammer and it is now part of its default installation. We also noticed
that problems which only Zipperposition can solve do pop up from time to time in
practice. Antoine Defourn√© also integrated Zipperposition in the TLA+ proof
assistant and observed that it helps prove some problems that were previously
out of reach \cite{ad-21-ho-tlaplus}.

Our extension of \lsup{} was guided by performance, rather than completeness
with respect to full higher-order logic. After the first victory, we were left
wondering what was the kind of problems that our implementation cannot
solve, and started looking for a complete full higher-order calculus. At the end,
we designed \osup{}, which gave us the precise answer in the form of problems that
cannot be solved and the rules which are necessary to solve them. 

While preparing for the following year's CASC competition, we found problems
that occur in practice for which the rules of \osup{} are necessary. However,
these problems occur in less than one percent of the whole TPTP library.
Furthermore, some of \osup{}'s rule are so explosive that they are disabled in
most CASC portfolio configurations.

This led us to take a radically different approach when extending Ehoh to
\ehohii{}. We envisioned \ehohii{} as a prover that excels on problems coming
from proof assistants. Unlike in TPTP, on these benchmarks hard, hand-crafted mathematical puzzles rarely occur.
Thus, we conjectured that extending \lfsup{} with the most rudimentary features
of $\lambda$-superposition such as full higher-order unification and
$\beta$-reduction-aware term orders would help us prove most of higher-order
problems without the explosion of complete approaches.

While this proved mostly true, we quickly realized that \ehohii{} should
assimilate most of the incomplete Boolean reasoning techniques described in Chapters
\ref{ch:bools} and \ref{ch:ho-techniques}. All of them were straightforward to
implement except for dynamic clausification, which we did not implement. It is
possible that support for this technique does not require profound changes to
E(hoh)'s formula treatment, but due to a lack of time we did not explore this
alley.

This highly pragmatic approach proved successful not only on proof assistant
benchmarks: \ehohii{} also excels on TPTP benchmarks, trailing slightly behind
Zipperposition. In the coming months we plan to replace Ehoh by \ehohii{} in Sledgehammer.
As Ehoh is already one of the most successful Sledgehammer backends,
this will further improve the efficiency of hundreds of mathematicians and computer scientists using Isabelle.
By manually expecting the TPTP benchmarks that are out of reach
for \ehohii{}, but within the reach of Zipperposition, we realized that resolving the lack of
dynamic clausification might be the weight necessary to tip the scales in
favor of \ehohii{} on TPTP benchmarks. 

This extension of Ehoh to \ehohii{} finished the third cycle. Inspired by our
approach of extending techniques designed for weaker logics to work in the
context of richer logics, we decided to look for ways in which superposition can
assimilate the most successful techniques of SAT solving. Extension of hidden
literals was straightforward, but finding the right way to tame their infinite
nature in the first-order case, as well as the right way to integrate equality
in their definition, was challenging. Predicate elimination posed challenges in
terms of finding the exact conditions under which it can be integrated with the
saturation loop. We first observed that blocked clause elimination destroys the
completeness of superposition calculus when we noticed that Zipperposition does
not prove some problems when the technique is enabled. After sifting through tens of
benchmarks and carefully examining the debugging information, we realized that
this was not due to a bug in the implementation but due to the incompatibility of
blocked clause elimination with the redundancy criterion. In the end, we were left
somewhat disappointed to learn that SAT techniques do not scale good enough to be used
as superposition simplification techniques. However, we learned that they are
very successful as preprocessing techniques.

% As it is customary, we will conclude the thesis with some remarks about the
% future work. \ehohii{} has been brought to the shape in which further
% experimentation with higher-order superposition is possible. From the experience
% gained in Chapters \ref{ch:bools} and \ref{ch:ho-techniques}, we can point out
% dynamic clausification as the main feature that is not yet implemented. It is planned to implement it in the future.

% In Chapter \ref{ch:ho-techniques} we only scratched the surface of finding
% appropriate heuristics. Now that \ehohii{} implements more advanced higher-order
% reasoning, it would be interesting to verify whether heuristics that are still not
% ported are agnostic of the version of implemented higher-order superposition
% calculus. 

% Some of the SAT-based techniques described in Chapter~\ref{ch:satfol} have been
% implemented in E as well. However, this implementation is still in its early
% phases as it is not properly tested and optimized. Verifying which techniques are
% prover-agnostic would increase the confidence in them. We also started the work
% of extending those techniques to full higher-order logic.

\section*{Future Work}

\looseness=-1
Even though the work in this thesis completes the three-step cycle, there are
still many unexplored alleys for future work. We separate them by the topic
explored in one of the earlier chapters:

\ourpara{Higher-Order Unification} The complete variant of the unification procedure
described in Chapter \ref{ch:unif} is proved complete with substantial
restrictions on the order and kind of applied rules. To further
remove redundancy, we plan to find alternative, less explosive unification rules
that do not compromise completeness. Furthermore, we want to investigate if
there are more combinations of unification rules that lead to redundant unifiers
and find ways to remove those redundancy-inducing combinations.

We also described only one pragmatic variant of the unification procedure. This
variant was designed after we sifted through hundreds of benchmarks to get a
taste of what unifiers occur in practice. It is possible that this pragmatic variant
can be further tweaked to perform more efficiently without loosing many useful unifiers.

Lastly, we fixed the order in which Zipperposition applies different unification
rules. It would be interesting to see if applying imitation before projection
(or vice versa) yields performance improvements on some kinds of problems. 
We also postponed the application of the most explosive rules such as iteration
to the very end. However, it would not be surprising that there are many hard hand-crafted
problems on which applying these rules early on would lead to a proof more quickly.

\ourpara{Pragmatic Techniques and Heuristics } Many of the Boolean reasoning
techniques described in Chapter \ref{ch:bools} were either inspired by the ones
implemented in traditional higher-order theorem provers or by the unsolved TPTP
benchmarks. Since the work present in Chapter \ref{ch:bools} anticipated the
complete higher-order calculus that could make these techniques obsolete, we
implemented only the most successful ones that are easy to port to
saturation-based provers.  Most notably, unlike Satallax
\cite{cb-2013-satallax}, Zipperposition does not use the fact that there only
finitely many functions of a type built using only the function type constructor
($\rightarrow$) and Boolean type ($o$). Implementing techniques for efficient
enumeration of all Boolean functions of a given type could help Zipperposition
prove problems that are still out of its reach, but can be solved by Satallax.

In Chapter \ref{ch:ho-techniques} we explored how we keep the explosion inherent
to the \osup{} calculus under control. Due to time and resource
constraints, in the evaluation of our new given-clause loop we fixed some
parameters that control which streams are queried. We plan to tune these
parameters in the future.  Similarly, we provided only some of the clause
priority functions that rely on higher-order features. We plan to investigate
more proofs in detail to create new priority functions that more cautiously
separate less and more useful higher-order inferences. Lastly, we observed that
use of Ehoh as a backend greatly improves the performance of Zipperposition. We
plan to further investigate the proofs that Ehoh returns and find out how
Zipperposition can find them without the use of a backend.

\ourpara{Further Extensions of \ehohii{}} \ehohii{} outperforms other provers on
problems coming from proof assistants. However, its performance on TPTP problems is
slightly behind Zipperposition. We plan to further investigate the benchmarks on
which \ehohii{} fails, but that are proved by Zipperposition. One of the first
features we plan implement is dynamic clausification, which can possibly help
improve \ehohii{}'s performance on first-order problems as well. We also plan to
experiment with implementing some of the \osup{} rules necessary for
completeness such as \infname{FluidSup}. Heuristics for \ehohii{} are trained on
a subset of Sledgehammer and TPTP problems. We plan to use other benchmark sets
such as GRUNGE \cite{bgksu-19-grunge} to make \ehohii{} efficient on a wider range of higher-order
benchmarks.

\ourpara{SAT-inspired eliminations for superposition} We already implemented
some of the techniques described in Chapter~\ref{ch:satfol} in E. However, this
implementation is not properly tested and optimized. We plan to put finishing
touches to this implementation and test the effects of implemented preprocessing
techniques on E's performance. There are more techniques used in SAT solving,
notably bounded variable addition \cite{mhb-12-reencoding} and blocked clause
addition \cite{ok-99-er}, that we did not port to first-order logic. We want to
investigate whether these techniques can be lifted to first-order logic. Lastly,
we already started work on porting existing techniques to higher-order logic.

