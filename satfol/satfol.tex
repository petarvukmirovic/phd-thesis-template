\chapter{SAT-Inspired Eliminations for Superposition}
\setheader{SAT-Inspired Eliminations for Superposition}
\label{ch:satfol}

\excludeversion{conf}
\includeversion{rep}
\includeversion{noqle}
\excludeversion{qle}
\newcommand{\paper}[0]{chapter}

\newcommand{\eqlit}[2]{\ensuremath{#1 \eq #2}}
\newcommand{\neqlit}[2]{\ensuremath{#1 \noteq #2}}
% \newcommand{\eqneqlit}[2]{\ensuremath{#1 \mathrel{\dot{\eq}} #2}}
\newcommand{\pospredlit}[1]{{#1}}
\renewcommand{\neglit}[1]{\neg{\kern.2ex #1}}
\newcommand{\negpredlit}[1]{\neglit{#1}}
\newcommand{\arbpredlit}[1]{(\neg)\kern.2ex\pospredlit{#1}}
\newcommand{\cor}{\ensuremath{\mathrel{\lor}}}
\newcolumntype{d}{D{.}{.}{0}}
\definecolor{light-gray}{gray}{0.925}
\newcommand\MAX[1]{\smash{\setlength{\fboxsep}{.3ex}\colorbox{light-gray}{\ensuremath{\vphantom{('q}{#1}}}}}




\authors{
    Joint work with\\
    Jasmin Blanchette
    and Marijn J.H. Heule
}

\begin{abstract}
Optimized SAT solvers not only preprocess the clause set, they also transform it
during solving as inprocessing. Some preprocessing techniques have been
generalized to first-order logic with equality. In this \paper, we port
inprocessing techniques to work with superposition, a leading first-order proof
calculus, and we strengthen known preprocessing techniques. Specifically, we
look into elimination of hidden literals, variables (predicates), and blocked
clauses. Our evaluation using the Zipperposition prover confirms that the new
techniques usefully supplement the existing superposition machinery.
\end{abstract}

\blfootnote{In this work I was the main designer behind all the presented techniques.
Marijn Heule did weekly supervision and provided his knowledge of SAT solving to 
guide the design of all techniques. Jasmin Blanchette found the exact conditions
under which superposition remains complete when predicate elimination rule is added
to the calculus. I also implemented and evaluated all the techniques. 
}

\newpage

\section{Introduction}
\label{sec:satfol:introduction}

Automated reasoning tools have become much more powerful in the last few
decades thanks to procedures such as conflict-driven clause learning (CDCL)
\cite{MSLM09HBSAT} for propositional logic and superposition
\cite{bg-94-superposition} for first-order logic with equality. However,
the effectiveness of these procedures crucially depends on how the input
problem is represented as a clause set. The clause set
can be optimized beforehand (\emph{preprocessing}) or during the execution of
the procedure (\emph{inprocessing}). In this \paper, we lift several preprocessing and
inprocessing techniques from propositional logic to clausal first-order logic
and demonstrate their usefulness in a superposition prover.

For many years, SAT solvers have used inexpensive clause simplification
techniques such as \emph{hidden literal} and \emph{hidden tautology elimination}
\cite{hjb-2010-cl-elim,hjb-2011-big-simplification} and \emph{failed literal
detection} \cite[Sect.~1.6]{jwf-1995-fld}. We generalize these techniques to
first-order logic with equality
(Sect.~\ref{sec:satfol:hidden-literal-based-elimination}). Since the generalization
involves reasoning about infinite sets of literals, we propose restrictions to
make them usable.

\emph{Variable elimination}, based on Davis--Putnam resolution \cite{dp-60-dp}, has
been studied in the context of both propositional logic
\cite{sp-04-niver,cs-00-zres} and quantified Boolean formulas (QBFs)
\cite{ab-2004-re}. The basic idea is to resolve all clauses with negative
occurrences of a propositional variable (i.e., a nullary predicate symbol) against
clauses with positive occurrences and delete the parent clauses. E\'en and
Biere \cite{eb-2005-satpreprocess} refined the technique to identify a subset
of clauses that effectively define a variable and use it to further optimize the
clause set. This latter technique, \emph{variable elimination by substitution},
has been an important preprocessor component in many SAT solvers since its
introduction in 2004.

\begin{sloppypar}
    Specializing second-order quantifier elimination
    \cite{go-1992-so-pred-elim,hjo-1996-scan}, Khasidashvili and Korovin~\cite{kk-2016-pe-fol} adapted variable elimination to preprocess first-order
    problems, yielding a technique we call \emph{singular predicate elimination}. We
    extend their work along two axes (Sect.~\ref{sec:satfol:predicate-elimination}): We
    generalize E\'en and Biere's refinement to first-order logic, resulting in
    \emph{defined predicate elimination}, and explain how both types of predicate
    elimination can be used during the proof search as inprocessing.    
\end{sloppypar}

\begin{qle}
It is well known that clauses containing \emph{pure literals}---predicate
literals whose root symbol occurs only with one polarity in the problem---can
be eliminated. We propose a generalization of this technique, under the name
\emph{quasipure literal elimination}, to allow the elimination of some bipolar
literals as well (Sect.~\ref{sec:satfol:quasipure-literal-elimination}).
\end{qle}

The last technique we study is \emph{blocked clause elimination} (Sect.\
\ref{sec:satfol:satisfiability-by-clause-elimination}). It is used in both SAT
\cite{jbh-10-BCE} and QBF solvers \cite{bls-11-bloqqer}. Its generalization to first-order
logic has produced good results when used as a preprocessor, especially on
satisfiable problems \cite{ksstb-2017-blockedfol}. We explore more ways to use
blocked clause elimination on satisfiable problems, including using it to
establish equisatisfiability with an empty clause set or as an inprocessing
rule. Unfortunately, we find that its use as inprocessing can compromise the
refutational completeness of superposition.


All techniques are implemented in the Zipperposition prover
(Sect.~\ref{sec:satfol:implementation}), allowing us to ascertain their usefulness
(Sect.~\ref{sec:satfol:evaluation}). The best configuration solves \NumberOK{160}
additional problems on benchmarks consisting of all 13\,495 first-order TPTP theorems
\cite{gs-17-tptp}. The raw experimental data are publicly available.%
\footnote{\url{https://doi.org/10.5281/zenodo.4552499}}\confrep{
More details, including all the proofs, can be found in a
technical report \cite{our-report}.}{}

\section{Preliminaries}
\label{sec:satfol:preliminaries}

% \ourpara{Clausal First-Order Logic}%
Our setting is many-sorted (i.e., many-typed), first-order
logic~\cite{jg-1987-logic-textbook} with interpreted equality and a
distinguished type (or sort) $o$. We introduced this logic in
Sect.~\ref{sec:pre:fol} and we use the same notation introduced in this section.
We write $\cst{f}^i(s)$ for the $i$-fold application of an unary symbol
$\cst{f}$ (e.g., $\cst{f}^3(x) = \cst{f}(\cst{f}(\cst{f}(x)))$) and call nullary
function symbols \emph{constants}. In this chapter, propositional variables
(corresponding to predicate constants in first-order logic) are written as
$\cst{x}, \cst{y}, \cst{p}, \cst{q}, \ldots$, while first-order free variables
are written in lowercase as $x,y,z,\ldots$.

We assume the same notion of substitution introduced in Sect.~\ref{sec:pre:fol}.
We extend the notation by writing a substitution $\{x_1 \mapsto t_1,
\ldots,\allowbreak x_n \mapsto t_n\}$ shortly as $\{ \tupleempty{x} \mapsto \tupleempty{t} \}$.
A substitution is a \emph{variable renaming} if it is a
bijection from a set of variables to a set of variables.


As we are working with clausal logic, we assume the clausal structure as defined
in Sect.~\ref{sec:pre:clauses}. In this section we use the uppercase letter $L$
to denote literals, as this is more customary in the related literature for
propositional logic. Recall that predicate literals  are encoded as
(dis)equations with equality. To simplify the notation in this chapter we write
predicate literals in unencoded form: positive literal $\eqlit{s}{\itrue}$ is
written as $s$ and negative literal $\neqlit{s}{\top}$ is written as
$\negpredlit{s}$. Literals $\eqlit{s}{t}$ where neither $s$ nor $t$ have the
type $o$ are called \emph{functional}. Given a literal $L$, we overload notation
and write $\neglit{L}$ to denote its complement. Clauses are often defined as
sets of literals, but superposition needs multisets; with multisets, an instance
$\sigmacl{C}$ always has the same number of literals as $C$, a most convenient
property. Given a clause set $N$, $\binset{N}$ denotes the subset of its binary
clauses: $\binset{N} = \{ L_1 \cor L_2 \mid L_1 \cor L_2 \in N \}$.

We assume the natural extensions of domain, valuation, interpretation and model
(as defined by Fitting \cite{mf-1996-fol}) from unsorted to many-sorted logic.
We also assume the notion of normal models from Sect.~\ref{sec:pre:fol} (with
corresponding notation) and extend it with the notion of \emph{cannonical
models}: A canonical model $\ourmodel$ is a normal model such that for every
element $d$ in one of $\ourmodel$'s domains there exists a ground term $t$ such
that $\ourmodel$ interprets $t$ as $d$. Canonical models generalize Herbrand
models \cite{mf-1996-fol} to first-order logic with equality: If a clause set is satisfiable, then
it is satisfiable in a canonical model.

All of the techniques described in this chapter are applied in the context of
first-order superposition which is introduced in Sect.~\ref{sec:pre:sup}. We
reuse all the notions introduced in this section and the corresponding notation. 

\section{Hidden-Literal-Based Elimination}
\label{sec:satfol:hidden-literal-based-elimination}

In propositional logic, binary clauses from a clause set $N$ can be used to
efficiently discover literals $L, L'$ for which the implication $L' \impl L$
is entailed by $N$'s binary clauses---i.e., $\binset{N} \models L' \impl L$.
Heule et al.\ \cite{hjb-2011-big-simplification} introduced the concept of \emph{hidden
literals} to capture such implications.

\begin{defi}
   Given a propositional literal $L$ and a propositional clause set~$N$, the
   set of \emph{propositional hidden literals} for $L$ and~$N$ is
   $\PHL(L, N) = \{ L' \mid L' \bigpimpl{N}^\ast L \} \setminus \{ L \}$, where $\bigpimpl{N}$ is
   defined such that $\neglit{L_1} \bigpimpl{N} L_2$ whenever $L_1 \cor L_2 \in N.$
   Moreover, $\PHL(L_1 \cor \cdots \cor L_n, N) = \bigcup_{i=1}^n
   \PHL(L_i, N)$.
\end{defi}

Heule et al.\ used a definition based on a fixpoint computation, but our
definition based on the reflexive transitive closure $\bigpimpl{N}^\ast$ of $\bigpimpl{N}$ is equivalent. Intuitively,
a hidden literal can be added to or removed from a clause without affecting its
semantics in models of~$N.$ By eliminating hidden literals from $C$, we simplify
it. By adding hidden literals to $C$, we might get a tautology $C'$ (i.e., a
valid clause:\ $\models C'$), meaning that $\binset{N} \models C$, thereby
enabling us to delete $C$. Note that $\PHL(L,N)$ is finite for a finite~$N.$

\begin{defi}
   \label{def:hle}\label{def:hte}
   Given $L' \cor L \cor C \in N,$ if $L' \in
   \PHL(L, N)$, \emph{hidden literal elimination} (HLE) replaces $N$ by $(N
   \setminus \{L' \cor L \cor C\}) \cup \{L \cor C\}$.
   Given $C \in N$, $\{L_1,\dots,L_n\} = \PHL(C, N)$, and $C' = C \cor L_1 \cor
   \cdots \cor L_n$, if $C'$ is a tautology, \emph{hidden
   tautology elimination} (HTE) replaces $N$ by $N \setminus \{C\}$.
\end{defi}

\begin{theorem}
   The result of applying HLE or HTE to a clause set $N$ is
   equivalent to $N$.
\end{theorem}

\begin{proof}
For HLE, if $L' \in \PHL(L, N)$,  $\binset{N} \models \neglit{L'} \cor L$. Then,
subsumption resolution (a sound rule that applies resolution followed by
subsumption \cite{bg-01-resolution}) yields shortened clause $L \cor C'$ from
Definition~\ref{def:hle}. For HTE, it can be shown that sets $N$ and $N
\cup \{ C' \} \setminus \{C\}$ are equivalent
\cite[Sect.~2.1]{hjb-2011-big-simplification}. As clause $C'$ is a tautology,
$N$ and $N \setminus \{C\}$ are equivalent.\qedhere
\end{proof}

We generalize hidden literals to first-order logic with equality by
considering substitutivity of variables as well as congruence of equality.

\begin{defi}
\label{def:hl-fo}
Given a literal $L$ and a clause set $N$,
the set of \emph{hidden literals} for $L$ and $N$
is $\HL(L,N) = \{ L' \mid L' \bigfimpl{N}^\ast L \} \setminus \{ L \}$, where
$\bigfimpl{N}$ is defined so that:
\begin{enumerate}
    \item $\sigmaterm{\neglit{L'}} \bigfimpl{N} \sigmaterm{L}$ if
    $L' \cor L \in N$ and $\sigma$ is a substitution
    \item $\eqlit{s}{t} \bigfimpl{N} \eqlit{u[s]}{u[t]}$ for all terms $s, t$ and
    contexts $u[\phantom{\cdot}]$
    \item $\neqlit{u[s]}{u[t]} \bigfimpl{N} \neqlit{s}{t}$ for all terms $s, t$ and
    contexts $u[\phantom{\cdot}]$
\end{enumerate}
% (1)~;
% (2)~; and
% (3)~.
Moreover, $\HL(L_1 \cor \cdots \cor L_n, N) = \bigcup_{i=1}^n \HL(L_i, N)$.
\end{defi}

\looseness=-1
The generalized definition also enjoys the key property that $L'
\in \HL(L, N)$ implies $\binset{N} \models L' \impl L$. However, $\HL(L, N)$
may be infinite even for predicate literals; for example,
$\pospredlit{\cst{p}(\cst{f}^i(x))} \in \HL(\pospredlit{\cst{p}(x)}, \{\pospredlit{\cst{p}(x)} \cor
\negpredlit{\cst{p}(\cst{f}(x))} \})$ for every $i$.

Based on Definition \ref{def:hl-fo}, we can generalize hidden literal elimination
and support a related technique:
\begin{align*}
    & \namedsimpsc{HLE}{L' \cor L \cor C}{L \cor C}{L' \in \HL(L,N)} \\[.5\jot]
    & \namedsimpsc{\rlap{FLE}\phantom{HLE}}{L \cor C}{C}{L',\neglit{L'} \in \HL(\neglit{L}, N)}
 \end{align*}
Recall that double lines denote simplification rules (Sect.~\ref{sec:pre:sup}).
The second rule is called \textit{failed literal elimination},
inspired by the SAT technique of asserting $\neglit{L}$ if $L$ is a \textit{failed literal} \cite{jwf-1995-fld}.
It is easy to see that rule \infname{HLE} is sound.
From $L' \in \HL(L,N)$ we have $N \models L' \impl L$ (i.e., $\neglit{L'} \cor L$).
Performing subsumption resolution \cite{bg-01-resolution} between $L'
\cor L \cor C$ and $\neglit{L'} \cor L$ yields the conclusion, which is
therefore entailed by $N.$ For \infname{FLE}, the condition $L',
\neglit{L'} \in \HL(\neglit{L},N)$ means that $\binset{N} \models \{\neglit{L'} \cor
\neglit{L}{,}\; L' \cor \neglit{L}\} \models \neglit{L}$.


\begin{exa}
   \label{example:hle}
   Consider the clause set $N = \{ \cst{p}(x) \cor \neglit{\cst{p}(\cst{f}(x))}{,}\;
   \cst{p}(\cst{f}(\cst{f}(x))) \cor \eqlit{\cst{a}}{\cst{b}} \}$ and the clause
   $C = \neqlit{\cst{f}(\cst{a})}{\cst{f}(\cst{b})} \cor \cst{p}(x)$. The first
   clause in $N$ induces $\cst{p}(\cst{f}(x)) \bigfimpl{N} {\cst{p}(x)}$,
   $\cst{p}(\cst{f}(\cst{f}(x))) \bigfimpl{N} \cst{p}(\cst{f}(x))$, and
   hence $\cst{p}(\cst{f}(\cst{f}(x))) \bigfimpl{N}^\ast  \cst{p}(x)$.
   Together with the second clause in $N$, it can be used to derive $\neqlit{\cst{a}}{\cst{b}}
   \bigfimpl{N}^\ast  \cst{p}(x)$. Finally, using rule 3 of Definition
   \ref{def:hl-fo}, we derive $\neqlit{\cst{f}(\cst{a})}{\cst{f}(\cst{b})}
   \bigfimpl{N}^\ast  \cst{p}(x)$---that is,
   $\neqlit{\cst{f}(\cst{a})}{\cst{f}(\cst{b})} \in \HL(\cst{p}(x), N)$. This
   allows us to remove $C$'s first literal using \infname{HLE}.
\end{exa}

Two special cases of \infname{HLE} exploit equality congruence as embodied by
conditions 2 and 3 of Definition~\ref{def:hl-fo} without requiring to
compute the $\HL$~set:
\begin{align*}
  %% TYPESETTING: \,'s below
  \namedsimp{CongHLE$^+$}{\eqlit{s}{t} \cor \eqlit{u[s]}{u[t]} \cor C}{\eqlit{u[s]}{u[t]} \cor C}\,\, \\[.5\jot]
  \namedsimp{CongHLE$^-$}{\neqlit{s}{t} \cor \neqlit{u[s]}{u[t]} \cor C}{\neqlit{s}{t} \cor C}
\end{align*}%

Hidden literals can be combined with unit clauses~$L'$ to remove more literals:
\[\namedsimpsc{UnitHLE}{L' \quad L \cor C}{L' \quad C}{\sigmaterm{L'} \in \HL(\neglit{L},N)}
%\text{~for some~}\sigma -- %%% Not necessary in a rule -- all variables are universally quantified. --JB
\]
%
Given a unit clause $L' \in N$, the rule uses it to discharge $\sigmaterm{L'}$ in
$N \models \sigmaterm{L'} \impl \neglit{L}$. As a result, we have $N \models
\neglit{L}$, making it possible to remove $L$ from $L \cor C$.

% Kiesl and Suda described first-order generalization of {\it asymmetric literals}
% \cite{ks-2017-unif-principle}: literal $L\sigma$ is asymmetric for a clause $C$
% and a clause set $N$ if there exists a clause $D \cor \neglit{L} \in N \setminus
% \{C \}$ such that $D\sigma \subseteq C$ for some substitution $\sigma$. 

\begin{exa}
   \label{example:unithle}
   \looseness=-1
   Consider the clause set $N = \{\cst{p}(x) \cor \cst{q}(\cst{f}(x)){,}\;
   \neglit{\cst{q}(\cst{f}(\cst{a}))} \cor \eqlit{\cst{f}(\cst{b})}{\cst{g}(\cst{c})}{,}\;
   \neqlit{\cst{f}(x)}{\cst{g}(y)}\}$ and the clause $C = \neglit{\cst{p}(\cst{a})} \cor
   \neglit{\cst{q}(\cst{b})}$. The first clause in $N$ induces
   $\neglit{\cst{q}(\cst{f}(\cst{a}))} \bigfimpl{N} \cst{p}(\cst{a})$, whereas
   the second one induces $\neqlit{\cst{f}(\cst{b})}{\cst{g}(\cst{c})} \bigfimpl{N}
   \neglit{\cst{q}(\cst{f}(\cst{a}))}$. Thus, we have $\neqlit{\cst{f}(\cst{b})}{\cst{g}(\cst{c})}
   \bigfimpl{N}^\ast \cst{p}(\cst{a})$---that is, $\neqlit{\cst{f}(\cst{b})}{\cst{f}(\cst{c})} \in
   \HL(\cst{p}(\cst{a}), N)$. By applying the substitution $\{x \mapsto \cst{b}{,}\allowbreak\; y
   \mapsto \cst{c}\}$ to the third clause in $N$, we can fulfill the conditions of
   \infname{UnitHLE} and remove $C$'s first literal.
\end{exa}

Next, we generalize hidden tautologies to first-order logic.

\begin{defi}
   A clause $C$ is a \emph{hidden tautology} for a clause set $N$ if there
   exists a finite set $\{L_1,\dots,L_n\} \subseteq \HL(C,N)$ such that
   $C \cor L_1 \cor \cdots \cor L_n$ is a tautology.
\end{defi}

\begin{exa}
   \label{example:hidden-tautologies-completeness}
   \looseness=-1
   In general, hidden tautologies are not redundant and cannot be deleted during saturation.
   Consider the unsatisfiable set $N = \{ \negpredlit{\cst{a}}{,}\;
   \negpredlit{\cst{b}}{,}\; \pospredlit{\cst{a}} \cor
   \pospredlit{\cst{c}}{,}\allowbreak\; \pospredlit{\cst{b}} \cor \negpredlit{\cst{c}}
   \}$, the order $\cst{a} \prec
   \cst{b} \prec \cst{c}$, and the empty selection function. The
   only possible superposition inference from $N$ is between the last two clauses,
   yielding the hidden tautology $\pospredlit{\cst{a}} \cor \pospredlit{\cst{b}}$
   (after simplifying away $\neqlit{\top}{\top}$), which is entailed by the larger
   clauses $\pospredlit{\cst{a}} \cor \pospredlit{\cst{c}}$ and
   $\pospredlit{\cst{b}} \cor \negpredlit{\cst{c}}$. If this clause is removed,
   the prover could enter an infinite loop, forever generating and deleting the
   hidden tautology\confrep{}{ and never getting the opportunity to derive the
   empty clause}.
\end{exa}

\begin{rep}
   \newcommand{\aset}{\mathcal{A}}
   \newcommand{\pset}{\mathcal{P}}
   
   In practice, most provers use a variant of the given clause procedure.
   Removing hidden tautologies breaks the invariant of the procedure that all
   inferences between clauses in $\aset$ are redundant. The end result is not
   that the prover diverges, but that it terminates without deriving empty
   clause.

   To observe this, assume the setting as in Example
   \ref{example:hidden-tautologies-completeness}, and let $\pset=N$ and
   $\aset=\emptyset$. After moving the first three clauses from $\pset$ to
   $\aset$ ($\aset = \{ \negpredlit{\cst{a}}, \negpredlit{\cst{b}}, \pospredlit{\cst{a}} \cor
   \pospredlit{\cst{c}} \}$, $\pset = \{\pospredlit{\cst{b}} \cor \negpredlit{\cst{c}}\}$), 
   no inferences are possible, and no new clauses are added to $\pset$. After the last clause
   is moved to $\aset$, the hidden tautology $\pospredlit{\cst{a}} \cor \pospredlit{\cst{b}}$
   is produced. If it is deleted, the prover terminates with the unsatisfiable set $\aset$,
   but does not derive the empty clause. 
\end{rep}

To delete hidden tautologies during saturation, the prover could check that all
the relevant clause instances encountered along the computation of $\HL$ are
$\prec$-smaller than a given hidden tautology. However, this would be expensive
and seldom succeed, given that superposition creates lots of nonredundant
hidden tautologies. Instead, we propose to simplify hidden tautologies using the
following rules:
%
%\begin{linenomath*}
% \begin{align*}
%    %% TYPESETTING: \,'s below
%    \namedsimpsc{HTR}{L \cor L' \cor C}{L \cor L'}{\neglit{L'} \in \HL(L, N)} &\\
%    \namedsimpsc{FLR}{L \cor C}{L}{L',\neglit{L'} \in \HL(L, N)} &
% \end{align*}
%
\begin{align*}
   & \namedsimpsc{HTR}{L \cor L' \cor C}{L \cor L'}{\neglit{L'} \in \HL(L, N) \text{~and~} C \not= \bot} \\[.5\jot]
   & \namedsimpsc{\rlap{FLR}\phantom{HTR}}{L \cor C}{L}{L',\neglit{L'} \in \HL(L, N) \text{~and~} C \not= \bot}
\end{align*}
%

%\end{linenomath*}
%
We call these techniques \emph{hidden tautology reduction} and \emph{failed literal
reduction}, respectively.
% \infname{FLD} is inspired by the \confrep{}{eponymous }SAT
% approach of asserting $L$ if $\neglit{L}$ is determined to be a failed literal
% \cite{jwf-1995-fld}.
%
Both rules are sound.
%
As with hidden literals, unit clauses~$L'$ can be exploited:
\[\namedsimpsc{UnitHTR}{L' \quad L \cor C}{L' \quad L}{\sigmaterm{L'} \in \HL(L,N) \text{~and~} C \not= \bot}
%\text{~for some~}\sigma
\]

We give the simplification rules above\confrep{}{ (for hidden literal
elimination, hidden tautology reduction,
failed literal detection, and their variants)} the collective name of
\emph{hidden-literal-based elimination} (HLBE).
Yet another use of hidden literals is for \emph{equivalent literal
substitution} \cite{hjb-2010-cl-elim}: If both $L' \in \HL(L, N)$ and $L
\in \HL(L', N)$, we can often simplify $\sigmacl{L'}$ to $\sigmacl{L}$ in $N$ if
$\sigmacl{L'} \succ \sigmacl{L}$. We want to investigate this~further.

% \looseness=-1
% Provers based on the DISCOUNT loop use only active clauses for
% simplification. If we restrict our attention to a finite subset of hidden
% literals, we can organize them into data structures that support efficient
% lookup of a hidden literal. Efficient implementation of these data structures
% allows to use all passive clauses for simplification, strengthening DISCOUNT
% loop simplification machinery.

\begin{theorem}
\begin{sloppypar}
The rules \infname{HLE}, \infname{FLE}, \infname{CongHLE$^+$},
\infname{Cong\allowbreak HLE$^-$}, \infname{UnitHLE}, \infname{HTR},
\infname{FLR}, and \infname{UnitHTR} are sound simplification rules.
\end{sloppypar}
\end{theorem}

\begin{rep}
\begin{proof}
It is easy to see that the deleted premises are entailed by the conclusions that
replace them and that the conclusions' instances are $\prec$-smaller than the
premises' instances, as required by the redundancy criterion. It remains to
check soundness.

\medskip

\noindent
\textsc{Case} \infname{HLE}:\enskip
We have $N{,}\> L' \models L$ by the side condition and must show
$N{,}\> L' \lor L \lor C \models L \lor C$. Let
$\ourmodel \models N{,}\> L' \lor L \lor C$. If $\ourmodel \models L'$, then
we also have $\ourmodel \models L$ thanks to the side condition and hence
$\ourmodel \models L \lor C$. Otherwise, we have $\ourmodel \models L \lor C$,
which is exactly what we need to show.

\medskip

\noindent
\textsc{Case} \infname{FLE}:\enskip
We have $N{,}\> L \models L'$ and $N, L \models \lnot L'$ by the side condition.
If $\ourmodel \models N{,}\> L$, then both $\ourmodel \models L'$ and
$\ourmodel \models \lnot L'$, an absurdity.
Otherwise, we have $\ourmodel \models C$, as desired.

\medskip

\noindent
\textsc{Case} \infname{CongHLE$^+$}, \infname{CongHLE$^-$}:\enskip
Obvious by congruence of equality.

\medskip

\noindent
\textsc{Case} \infname{UnitHLE}:\enskip
We have $N{,}\> L \models \lnot \sigmaterm{L'}$ by the side condition. If $\ourmodel
\models N{,}\> L$, then $N \models \lnot \sigmaterm{L'}$. But since $L' \in N$, this is
an absurdity. Otherwise, we have $\ourmodel \models C$, as desired.

\medskip

\noindent
\textsc{Case} \infname{HTR}:\enskip
We have $N{,}\> \lnot L' \models L$ by the side condition. If either $\ourmodel
\models L$ or $\ourmodel \models L'$, the desired result follows directly.
Otherwise, from $\ourmodel \models \lnot L'$ we also have $\ourmodel \models L$
thanks to the side condition, contradicting $\ourmodel \models \lnot L$.

\medskip

\noindent
\textsc{Case} \infname{FLR}:\enskip
We have $N{,}\> L' \models L$ and $N{,}\> \lnot L' \models L$ by the side condition.
Hence $N \models L$, as desired.

\medskip

\noindent
\textsc{Case} \infname{UnitHTR}:\enskip
We have $N{,}\> \sigmaterm{L'} \models L$. Since $L' \in N$, we have $N \models L$,
as desired.
\qedhere
\end{proof}
\end{rep}

\section{Predicate Elimination}
\label{sec:satfol:predicate-elimination}

For propositional logic, variable elimination \cite{eb-2005-satpreprocess} is
one of the main preprocessing and inprocessing techniques. Following Gabbay and Ohlbach's ideas
\cite{go-1992-so-pred-elim}, Khasidashvili and Korovin \cite{kk-2016-pe-fol}
generalized variable elimination to first-order logic with equality and
demonstrated that it is effective as a preprocessor. We propose an improvement
that makes this applicable in more cases and show that, with a minor
restriction, it can be integrated in a superposition prover
without compromising its refutational completeness.

\subsection{Singular Predicates}

Khasidashvili and Korovin's preprocessing technique removes singular predicates
(which they call ``non-self-referential predicates'') from the problem using
so-called flat resolution.

\begin{defi}
   A predicate symbol is called \emph{singular}\confrep{ (or ``non-self-referential'')}{}
   for a clause set $N$ if it occurs at most once in every clause contained in
   $N.$
\end{defi}

\begin{defi}
   \label{def:flat-res}
   Let $C = \pospredlit{\cst{p}(\tuplen{s})} \cor C'$ and $D =
   \negpredlit{\cst{p}(\tuplen{t})} \cor D'$ be clauses with no variables in
   common. The clause $\neqlit{s_1}{t_1} \cor \cdots \cor \neqlit{s_n}{t_n}
   \cor C' \cor D'$ is a \emph{flat resolvent} of $C$ and $D$ on $\cst{p}$.
\end{defi}

% Predicate elimination saturates with respect to flat resolvents, removing all
% clauses containing $\cst{p}$. Given two (possibly identical) clause sets $M, N$,
% the resolved set $M \flatres_{\!\cst{p}} N$, defined below, repeatedly draws
% one inference partner from $M$ and the other one from $N$.

Given two (possibly identical) clause sets $M, N$, predicate elimination
iteratively replaces clauses from $N$ containing the symbol $\cst{p}$ with all flat
resolvents against clauses in $M$. Eventually, it yields a
set with no occurrences of $\cst{p}$.


\begin{defi}
\label{def:flat-res-set}
   Let $M, N$ be clause sets and $\cst{p}$ be a singular predicate for
   $M$. Let $\flatresiter$ be the following relation on clause set pairs and clause sets:
   \begin{enumerate}
   \item $(M{,}\> \{\arbpredlit{\cst{p}(\tupleempty{s})} \cor C'\} \uplus N) \flatresiter (M{,}\; N' \cup N)$ if
   $N'$ is the set that consists of all clauses (up to variable renaming) that are flat resolvents
   with $\arbpredlit{\cst{p}(\tupleempty{s})} \cor C'$ on $\cst{p}$ and a clause from $M$ as premises.
   The premises' variables are renamed apart.

   \smallskip
   \item $(M, N) \flatresiter N$ if $N$ has no occurrences of $\cst{p}$.
   \end{enumerate}
   \noindent  The \emph{resolved set} $M \flatres_{\!\cst{p}} N$ is the clause set $N'$ such that $(M,N) \flatresiter^* N'$.
   % obtained by the following
   % procedure: Set $N' = N$. Then repeatedly (1)~choose a clause $D \in N'$
   % containing $\cst{p}$, (2)~compute all flat resolvents involving $D$ and
   % partners from $M$, renaming variables apart, and (3)~replace $D$ with these
   % flat resolvents in $N'$. Stop when $N'$ contains no more occurrence of
   % $\cst{p}$.
\end{defi}

\pagebreak[2]

\begin{rep}
\begin{lemma}
   \label{lem:flat-res-set-termination-confluence}
   Let $M, N$ be clause sets and $\cst{p}$ be a singular predicate for
   $M$. The resolved set $N'$ is reached in a finite number of $\flatresiter$ steps,
   and it is unique up to variable renaming.
\end{lemma}
\begin{proof}
   To show $\flatresiter$ is terminating we use the following ordinal measure on
   clause sets: $\nu(\{D_1,\dotsc,\allowbreak D_n\}) = \omega^{\nu(D_1)} \oplus
   \cdots \oplus \omega^{\nu(D_n)}$, where $\nu(D)$ is the number of
   occurrences of $\cst{p}$ in $D$, $\omega$ is the first infinite ordinal, and
   $\oplus$ is the Hessenberg, or natural, sum, which is commutative.
   For every transition
   $(M, \{C\} \cup N) \flatresiter (M, N' \cup N)$, we have $\nu(\{C\} \cup N) > \nu(N' \cup N)$
   because $\omega^{\nu(C)} > \omega^{\nu(C)-1} \cdot |N'|$.
   Eventually, a state $(M,N')$ with $\nu(N')=\omega^0\cdot n$ is reached.
   Then, we apply the second rule of Definition \ref{def:flat-res-set} to obtain the resolved set $N'$.

   To show that $N'$ is unique, i.e., $\flatresiter$ is confluent, it suffices
   to show (since $\flatresiter$ is terminating and Newmann's lemma applies
   \cite{bn-98-tr-and-all-that}) that $\flatresiter$ is locally confluent. In
   other words, whenever $(M,N) \flatresiter (M, N_1)$ and $(M,N) \flatresiter
   (M, N_2)$ there exists $N'$ such that $(M, N_1) \flatresiter (M, N')$ and
   $(M, N_2) \flatresiter (M,N')$. 
   
   There are two main sources of nondeterminism of $\flatresiter$: The choice of $C
   \in N$ and the choice of the literal in $C$ to act on. Let us focus on the choice of
   $C$ in $N$; the same discussion applies for the choice of literal in $C$.

   Let $N = \{C_1\} \uplus \{C_2\} \uplus N'$, where $C_1$ and $C_2$ are
   clauses with occurrences of $\cst{p}$. Then, $(M, \{C_1\} \uplus \{ C_2 \cup
   N' \}) \flatresiter (M, N'_1 \cup \{ C_2 \cup N'\})$ and $(M, \{C_2\} \uplus
   \{C_1 \cup N' \}) \flatresiter (M, N'_2 \cup \{ C_1 \cup N' \})$ where $N'_1$ and
   $N'_2$ are sets of corresponding resolvents. Both of $\flatresiter$ steps can
   be joined (up to variable renaming) to $(M, N'_1 \cup N'_2 \cup N')$, showing
   that $\flatresiter$ is locally confluent.
\end{proof}
\end{rep}

\begin{conf}
The relation $\flatresiter$ is confluent up to variable renaming. Thanks to
the singularity constraint on $M$, it
also terminates on finite sets because the following ordinal measure decreases:
$\nu(\{D_1,\allowbreak\dotsc,\allowbreak D_n\}) = \omega^{\nu(D_1)} \oplus \cdots \oplus
\omega^{\nu(D_n)}$, where $\nu(D)$ counts the occurrences of $\cst{p}$ in
$D$, $\omega$ is the first infinite ordinal,
and $\oplus$ is the Hessenberg, or natural, sum, which is commutative.
For every transition
$(M, \{C\} \cup N) \flatresiter (M, N' \cup N)$, we have
$\nu(\{C\}) = \omega^{\nu(C)} > \omega^{\nu(C)-1} \cdot |N'| = \nu(N')$.
\end{conf}

Next, it is useful to partition
clause sets into subsets based on the presence and polarity of a singular
predicate.

\begin{defi}
   Let $N$ be a clause set and $\cst{p}$ be a singular predicate for
   $N.$ Let $\withpredpos{N}{\cst{p}}$ consist of all clauses of the form $\pospredlit{\cst{p}(\tuple{s}{})} \cor C' \in N$,
   let $\withpredneg{N}{\cst{p}}$ consist of all clauses of the form $\negpredlit{\cst{p}(\tuple{s}{})} \cor C' \in N$,
   let $\withpred{N}{\cst{p}} = \withpredpos{N}{\cst{p}} \cup \withpredneg{N}{\cst{p}}$,
   and let $\withoutpred{N}{\cst{p}} = N \setminus \withpred{N}{\cst{p}}$.
\end{defi}

\begin{defi}
   \label{def:pred-elim}
   Let $N$ be a clause set and $\cst{p}$ be a singular predicate for
   $N.$
   \emph{Singular predicate elimination} (SPE) of $\cst{p}$ in $N$ replaces $N$ by
   $\withoutpred{N}{\cst{p}} \cup (\withpredpos{N}{\cst{p}} \flatres_{\!\cst{p}} \withpredneg{N}{\cst{p}})$.
\end{defi}

The result of SPE is satisfiable if and only if $N$ is satisfiable
\cite[Theorem~1]{kk-2016-pe-fol}, justifying SPE's use in a preprocessor.
However, eliminating singular predicates aggressively can dramatically increase
the number of clauses. To prevent this, Khasidashvili and Korovin suggested to
replace $N$ by $N'$ only if $\lambda(N') \leq \lambda(N)$
and $\mu(N') \leq \mu(N)$, where
$\lambda(N)$ is the number of literals in~$N$ and
$\mu(N)$ is the sum for all clauses $C \in
N$ of the square of the number of distinct variables in $C$.

Compared with what modern SAT solvers use, this
criterion is fairly restrictive. We relax it to make it possible to
eliminate more predicates, within reason. Let $K_\mathrm{tol} \in \mathbb{N}$ be a tolerance
parameter. A predicate elimination
step from $N$ to $N'$ is allowed if
$\lambda(N') < \lambda(N) + K_\mathrm{tol}$ or
$\mu(N') < \mu(N)$ or
$|N'| < |N| + K_\mathrm{tol}$.
\confrep{}{A refinement, which we want to try out in future work, would be to gradually
increment the tolerance $K_\mathrm{tol}$, as is done in some SAT solvers.}


\subsection{Defined Predicates}

SPE is effective, but an important refinement has not yet been adapted to
first-order logic:\ variable elimination by substitution. E{\'{e}}n and Biere
\cite{eb-2005-satpreprocess} discovered that a propositional variable~$\cst{x}$ can be
eliminated without computing all resolvents if it is expressible as an
equivalence $\cst{x} \medleftrightarrow \varphi$, where $\varphi$, the ``gate,''
is an arbitrary formula that does not reference~$\cst{x}$.
They partition a set $N$
\confrep{}{of propositional clauses }into a definition set $G$, essentially the
clausification of $\cst{x} \medleftrightarrow \varphi$, and
$R = \withpred{N}{\cst{p}} \setminus G$, the remaining
clauses containing~$\cst{p}$. To eliminate $\cst{x}$ from $N$ while
preserving satisfiability, it suffices to resolve clauses from $G$ against
clauses from $R$, effectively substituting $\varphi$ for $\cst{x}$ in $R$.
Crucially, we do not need to resolve pairs of clauses from $G$
or pairs of clauses from $R$.
We generalize this idea to first-order logic.

\begin{defi}
   \label{def:definition}
   \looseness=-1
   Let $G$ be a clause set, $\cst{p}$ be a predicate symbol, and
   $\tupleempty{x}$ be distinct variables.
%
   The set $G$ is a \emph{definition set} for $\cst{p}$ if
   \begin{enumerate}
      \item $\cst{p}$ is singular for $G$
      \item $G$ consists of clauses of the form $\arbpredlit{\cst{p}(\tupleempty{x})} \cor C'$ (up to variable renaming)
      \item the variables in $C'$ are all among $\tupleempty{x}$
      \item all clauses in $\withpredpos{G}{\cst{p}}
      \flatres_{\!\cst{p}} \withpredneg{G}{\cst{p}}$ are tautologies
      \item $E(\tupleempty{\cst{c}})$ is unsatisfiable, where
      the \emph{environment} $E(\tupleempty{x})$ consists of all subclauses $C'$ of any
      $\arbpredlit{\cst{p}(\tupleempty{x})} \mathbin{\cor} C' \in G$ and
      $\tupleempty{\cst{c}}$ is a tuple of distinct fresh constants substituted
      in for $\tupleempty{x}$
   \end{enumerate}
\end{defi}

A definition set $G$ corresponds intuitively to a definition by
cases in mathematics---e.g.,
\[\cst{p}(\tuple{x}{}) =
\begin{cases} \top & \mathrm{if}~\varphi(\tuple{x}{}{}) \\[-\jot]
\bot & \mathrm{if}~\psi(\tuple{x}{})\end{cases}\]
Part~4 states that the case conditions are mutually exclusive
(e.g., $\neglit{\varphi(\tuple{x}{})} \lor \neglit{\psi(\tuple{x}{})}$),
and part~5 states that they are exhaustive
(e.g., $\nexists\tuple{\cst{c}}{} .\; \neglit{\varphi(\tuple{\cst{c}}{})} \land \neglit{\psi(\tuple{\cst{c}}{})}$).
%
Given a quantifier-free formula $\cst{p}(\tuple{x}{}) \medleftrightarrow
\varphi(\tuple{x}{})$ with distinct variables $\tuple{x}{}$ such that
$\varphi(\tuple{x}{})$ does not contain $\cst{p}$, any reasonable
clausification algorithm would produce a definition set for $\cst{p}$.

\begin{exa}
   \label{example:tautologies}
   Given the formula $\cst{p}(x) \medleftrightarrow \cst{q}(x) \mathrel\land
   (\cst{r}(x) \cor \cst{s}(x))$, a standard clausification algorithm
   \cite{nw-01-small-cnf} produces $\{ \negpredlit{\cst{p}(x)} \cor
   \pospredlit{\cst{q}(x)}{,}\; \negpredlit{\cst{p}(x)} \cor
   \pospredlit{\cst{r}(x)} \cor \pospredlit{\cst{s}(x)}{,}\;
   \pospredlit{\cst{p}(x)} \cor \negpredlit{\cst{q}(x)} \cor
   \negpredlit{\cst{r}(x)}{,}\; \pospredlit{\cst{p}(x)} \cor
   \negpredlit{\cst{q}(x)} \cor \negpredlit{\cst{s}(x)}\}$, which qualifies
   as a definition set for $\cst{p}$.
\end{exa}

Definition sets generalize E{\'{e}}n and Biere's
gates. They can be recognized syntactically for formulas such as
$\cst{p}(\tuple{x}{}) \medleftrightarrow \bigvee_{\!i} \cst{q}_i(\tuple{s_i}{})$ or
$\cst{p}(\tuple{x}{}) \medleftrightarrow \bigwedge_i \cst{q}_i(\tuple{s_i}{})$,
or semantically: Condition~4 can be checked
using the congruence closure algorithm, and condition~5 amounts to
a propositional unsatisfiability check.

The key result about propositional gates carries over to definition sets.

\begin{defi}
   \looseness=-1
   Let $N$ be a clause set, $\cst{p}$ be a predicate symbol,
   $G \subseteq N$ be a definition set
   for $\cst{p}$, and $R = \withpred{N}{\cst{p}}
   \setminus G$. \emph{Defined predicate elimination} (DPE) of $\cst{p}$ in $N$ replaces $N$ by
   $\withoutpred{N}{\cst{p}} \cup
%%% @PETAR: Double-check the supression of _p below. --JB
   (\confrep{\withpred{G}{\cst{p}}}{G} \flatres_{\!\cst{p}} \confrep{\withpred{R}{\cst{p}}}{R})$.
\end{defi}

\newcommand{\mm}{\ourmodel}
\newcommand{\notmodels}{\nvDash}
\begin{rep}
   \begin{lemma}
   \label{lem:unsat-fresh-consts}
   Let $N(\tupleempty{x})$ be a clause set such that the variables of all
   clauses in it are among the argument $n$-tuple $\tupleempty{x}$, and let
   $\tupleempty{\cst{c}}$ be an $n$-tuple of distinct fresh constants. If
   $N(\tupleempty{\cst{c}})$ {\upshape(}i.e.,
   $\substterm{\{\tupleempty{x}\mapsto\tupleempty{\cst{c}}\}}{N(\tupleempty{x})}${\upshape)} is
   unsatisfiable, then for every interpretation $\mm$ and valuation $\xi$,
   $\mm \notmodels_\xi N$.
   \end{lemma}
   \begin{proof}
      We show the contrapositive. Assume that for some $\mm$ and $\xi$,  $\mm \models_\xi N(\tupleempty{x})$.
      Then let $\ourmodel'$
      be a model that assigns each $\cst{c}_i$ the interpretation of $x_i$ under $\mm$ and $\xi$, and otherwise
      coincides with $\ourmodel$. We obtain $\ourmodel' \models N(\tupleempty{\cst{c}})$.
   \end{proof}

   \begin{lemma}
      \label{lem:flat-res-set-step-satisfiability}
      Let $G$ be a definition set for $\cst{p}$\confrep{,}{} and $N$ \confrep{}{be }an arbitrary clause
      set. If $(G, N) \flatresiter (G, N')$ then $G \cup N$ and $G \cup N'$ are
      equivalent.
   \end{lemma}
   \begin{proof}
      Since flat resolution is sound, the nontrivial direction is to show that a
      model $\mm$ of the set $G \cup N'$ is also a model of $G \cup N$. As the only clause in $N
      \setminus N'$ is $C = \arbpredlit{\cst{p}(\tuple{s}{n})} \cor C'$ on which
      the $\flatresiter$ step is performed, we must show $\mm \models C$.
      % Without 

      % Let $\mm$ be canonical model of $G \cup N'$ \cite[Theorem~9.5.2]{mf-1996-fol} and let $C
      % \in N \setminus N'$. We need to show that $\mm \models C$---which is to say,
      % for all variable interpretation $\xi$, we have $\mm \models_\xi C$. To
      % lighten notations, we will assume $C$ is ground and ignore $\xi$. Canonical
      % models make this step possible.

      % First, $C$ must have the form $\arbpredlit{\cst{p}(\tuple{s}{})} \cor C'$,
      % where $\tuple{s}{}$ is a tuple of ground terms. 
      Without loss of generality,
      we assume that the leading literal of $C$ is positive.
      Towards a contradiction, assume $\xi$ is a valuation such that $\mm \notmodels_\xi C$. Then, $\mm \notmodels_\xi
      \pospredlit{\cst{p}(\tuple{s}{n})}$. 
      % Let $\xi'$ be a valuation that
      % assigns every instance $D = \pospredlit{\cst{p}(\tupleempty{s})} \cor D'$ of a clause in
      % $G$, since $\mm \notmodels \pospredlit{\cst{p}(\tuple{s}{})}$, we have $\mm
      % \models D'$.
      Consider an arbitrary clause $D = \pospredlit{\cst{p}}(\tuplen{x}) \cor D'
      \in \withpredpos{G}{\cst{p}}$ and a valuation $\xi'$, which assigns each $x_i$ the
      interpretation of $s_i$ under $\mm$ and $\xi$. As $\mm \notmodels_{\xi'}
      \pospredlit{\cst{p}}(\tuple{x}{n})$ and $\mm \models G$, then $\mm \models_{\xi'} D'$ for every
      such clause $D$.
   %
      However, by part 5 of Definition~\ref{def:definition} and by Lemma
      \ref{lem:unsat-fresh-consts}, $\mm \notmodels_{\xi'} E(\tuplen{x})$, where $E(\tuplen{x})$
      is the environment associated with the definition set $G$.
      Therefore, there must exist a clause $D =
      \negpredlit{\relax{\cst{p}(\tuplen{x})}} \cor D'$ in $\withpredneg{G}{\cst{p}}$ such
      that $\mm \notmodels_\xi D'$.


      Now consider the flat resolvent of $C$ and $D$ on~$\cst{p}$: $R =
      \neqlit{x_1}{s_1} \cor \cdots \cor \neqlit{x_n}{s_n} \cor C' \cor D'$.
      Let $\zeta$ be a valuation coinciding with $\xi$ on variables of $C$
      and with $\xi'$ on $\tuplen{x}$.
      Clearly, $\mm \notmodels_\zeta R$. Yet, $R \in N'$, and as $\mm \models N'$, we reach a contradiction.
   \end{proof}

   \begin{lemma}
      \label{lem:flat-res-set-last-step-satisfiability}
      Let $G$ be a definition set for $\cst{p}$\confrep{,}{} and $N$ \confrep{}{be }a clause set with no occurrences of $\cst{p}$.
      Then $G \cup N$ is satisfiable if and only if $N$ is satisfiable.
   \end{lemma}
   \begin{proof}
      The nontrivial direction is to show that if $N$ is satisfiable, $G \cup N$ is as well.
      %
      Let $\mm$ be a model of $N$. We construct a model $\mm'$ of $G$ over
      the same universe as $\mm$. For any atom $A$ such that $\cst{p}$ does not
      occur in $A$ and for every $\xi$, we set $\mm' \models_\xi A$ if and only if
      $\mm \models_\xi A$. For any clause $\pospredlit{\cst{p}(\tuplen{x})} \cor
      C' \in G$ and any assignment $\xi$ such that $\mm \notmodels_\xi C'$, we
      define $\mm'$ so that $\mm'\models_\xi \cst{p}(\tuplen{x})$. By
      construction, $\mm' \models \withpredpos{G}{\cst{p}} \cup N$. It remains to show that $\mm' \models
      \withpredneg{G}{}$.

      Let $C = \negpredlit{\cst{p}(\tuplen{x})} \cor C' \in G$ and let $\xi$ be
      an arbitrary assignment. Towards a contradiction, assume
      $\mm'\notmodels_\xi C$, and consequently $\mm' \models_\xi
      \cst{p}(\tuplen{x})$. By construction of $\mm'$, there exists a clause
      $\pospredlit{\cst{p}(\tuplen{y})} \cor D' \in G$ and an assignment $\xi'$
      which assigns each $y_i$ value of $\xi(x_i)$ such that $\mm
      \notmodels_{\xi'} D'$. The resolvent $R = \neqlit{x_1}{y_1} \lor \cdots \lor
      \neqlit{x_n}{y_n} \lor C' \lor D'$ is a tautology, according to condition
      4 of Definition \ref{def:definition}. However, for a valuation that
      behaves like $\xi$ on $\tupleempty{x}$ and $\xi'$ on $\tupleempty{y}$,
      $\mm'$ does not satisfy $R \in N$, contradicting our assumption.
      % @Jasmin: Your trick with var renaming does not work as flat resolvent is
      % defined on
      % variable-disjoint clauses.
   \qedhere
   \end{proof}
\end{rep}
\begin{conf}

\end{conf}
\begin{theorem}
\label{thm:pes-sat-equiv}
   The result of applying DPE to a clause set $N$ is
   satisfiable if and only if $N$ is satisfiable.
\end{theorem}
\begin{rep}
\begin{proof}
   Let $\cst{p}$ be a predicate symbol and $G \subseteq N$ be the
   definition set used by DPE, and let $R = \withpred{N}{\cst{p}} \setminus G$.
%
   % First, using Lemmas \ref{lem:flat-res-set-termination-confluence} and \ref{lem:flat-res-set-step-satisfiability}
   % we show that we will eventually obtain a set $R'$
   % that contains no occurrences of $\cst{p}$ and that preserves satisfiability
   % of the original $R$. Finally, we will show that we can
   % omit $G$ in the result without affecting satisfiability.

   Using Lemma
   \ref{lem:flat-res-set-termination-confluence}, we get that there is a
   derivation $(G,R) \flatresiter^n (G,R') \flatresiter R'$. Applying Lemma
   \ref{lem:flat-res-set-step-satisfiability} $n$ times, we get that $G \cup R$
   is equivalent to $G \cup R'$. Finally, Lemma \ref{lem:flat-res-set-last-step-satisfiability}
   gives us the desired result.
\end{proof}
\end{rep}

Since there will typically be at most only a few defined predicates in the
problem, it makes sense to fall back on SPE when no definition is found.

\begin{defi}
   \looseness=-1
   Let $N$ be a clause set and $\cst{p}$ be a predicate symbol. If there exists a
   definition set $G \subseteq N$ for $\cst{p}$, \emph{portfolio predicate
   elimination} (PPE) on $\cst{p}$ in $N$ replaces $N$ with
%%% @PETAR: Double-check the supression of _p below. --JB
   $\withoutpred{N}{\cst{p}} \cup (\confrep{\withpred{G}{\cst{p}}}{G} \flatres_{\!\cst{p}}
   \confrep{\withpred{R}{\cst{p}}}{R})$, where $R = \withpred{N}{\cst{p}} \setminus G$.
   Otherwise, if $\cst{p}$ is singular in $N$, it results in $\withoutpred{N}{\cst{p}}
   \cup (\withpredpos{N}{\cst{p}} \flatres_{\!\cst{p}} \withpredneg{N}{\cst{p}})$.
   In all other cases, it is not applicable.
\end{defi}

