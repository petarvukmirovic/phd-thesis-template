\chapter{Making Higher-Order Superposition Work}
\setheader{Making Higher-Order Superposition Work}
\label{ch:ho-techniques}

\authors{
    Joint work with\\
    Alexander Bentkamp,
    Jasmin Blanchette,
    Simon Cruanes,
    Visa Nummelin, and Sophie Tourret
}

\blfootnote{In this work I was the main designer of all presented techniques,
with the exception of inference streams which were designed by Sophie Tourret
and Alexander Bentkamp. Alexander Bentkamp and Jasmin Blanchette also discussed many
of the techniques with me and suggested important updates. Visa Nummelin worked on
implementation of FOOL preprocessing. Simon Cruanes is the original developer
of Zipperposition and provided us with invaluable knowledge.
}


\begin{abstract}
    Superposition is among the most successful calculi for first-order logic. Its
    extension to higher-order logic introduces new challenges such as infinitely
    branching inference rules, new possibilities such as reasoning about
    Booleans, and the need to curb the explosion of specific higher-order rules. We
    describe techniques that address these issues and extensively evaluate their
    implementation in the Zipperposition theorem prover. Largely thanks to their use,
    Zipperposition won the higher-order division of the CASC competition in 2020.  
  \end{abstract}
\newpage

\section{Introduction}
\label{sec:ho-tech:intro}

% %In recent decades,
% Superposition-based first-order automatic theorem provers
% have emerged as useful reasoning tools. They dominate at the annual CASC
% \cite{gs-2016-casc} theorem prover competition, having always won the
% first-order theorem division. They are also used as backends to proof assistants
% \cite{ck-18-coqhammer,ku-15-holyhammer,pb-12-sh}, automatic
% higher-order theorem provers \cite{sb-21-leo3}, and software verifiers
% \cite{fp-13-why3}.

% The superposition calculus has only recently been extended
% to higher-order logic (more precisely, extensional simple type theory
% \cite{henkin-1950-completeness}), resulting in
% \emph{\lsup} \cite{bbtvw-21-sup-lam}, which we developed
% together with Waldmann, as well as \emph{combinatory superposition}
% \cite{br-20-full-sup-w-combs} by Bhayat and Reger. Although these two
% calculi do not support an interpreted Boolean type,
% they can be extended by ad hoc rules \cite{our-bool-paper} that support
% most of the Boolean reasoning necessary in practice.

% Both higher-order superposition calculi were designed to gracefully
% extend first-order reasoning. As most steps in higher-order
% proofs tend to be essentially first-order, extending the most successful first-order
% calculus to higher-order logic seemed worth trying.
% Our first attempt at testing this idea was in 2019:
% Zipperposition~1.5, based on \lsup, finished third
% in the higher-order theorem division of CASC-27 \cite{gs-19-casc27},
% 12~percentage points behind the winner, the tableau prover Satallax 3.4 \cite{cb-2013-satallax}.

The landscape of higher-order proving techniques based on extension of efficient
first-order ones has tremendously expanded in the late 2010s and early 2020s. As
mentioned is Sect.~\ref{sec:pre:ho-sup-calculi} we have implemented three
higher-order calculi---\lfsup{}, \lsup{}, and \osup{}---which extend first-order superposition in a graceful way.
Bhayat and Reger also gracefully extended superposition to higher-order logic using
\textsf{SKBCI} combinators \cite{br-20-full-sup-w-combs}. Significant progress has been
made on SMT front as well \cite{brotb-19-ho-smt}.

In 2019 we tested if the idea of gracefully extending first-order provers to
higher-order logic really improves the state of the art for the first time. We implemented \lsup{} \cite{bbtvw-21-sup-lam} in
Zipperposition~1.5 with basic heuristics and rudimentary extensions of the
calculus to deal with Booleans. It finished third at that year's higher-order
division of CASC competition \cite{gs-19-casc27}, 12~percentage points behind the
winner, the tableau prover Satallax 3.4 \cite{cb-2013-satallax}.

Studying the competition results, we found that higher-order tableaux have some
advantages over higher-order superposition. To bridge the gap, we developed
techniques and heuristics that simulate tableaux in the context of saturation.
We implemented them in Zipperposition~2, which took part at the higher-order
division of CASC \cite{gs-21-cascj10} in 2020. This time, our prover won the
division, proving 84\% of the problems, a whole 20~percentage points ahead of
the runner-up, Satallax 3.4.

In this chapter, we describe the main techniques that explain this reversal of
fortunes. They cover most parts of a modern higher-order theorem prover, from
preprocessing to additional calculus rules to heuristics to backend integration.
Compared to the previous chapter, in which we discussed rules used to treat
Boolean terms, in this chapter we use a newer version of Zipperposition, based
on a newer calculus. Instead of \lsup{} augmented with ad hoc Boolean rules, we
work with {\osup} \cite{bbtv-21-full-ho-sup}, a principled extension of
superposition to full higher-order logic, including an interpreted Boolean type.

Many higher-order problems extensively use symbol definitions to simplify
their representation. We describe several ways to exploit the definitions,
%of which the most successful is
such as turning them into rewrite rules (Sect.~\ref{sec:ho-tech:preprocessing}).
%Interesting patterns can be observed in various higher-order problem encodings.
%We show how we can exploit these to simplify problems (Sect.~\ref{sec:ho-tech:preprocessing}).
%
By working on formulas rather than clauses, tableau techniques take a more
holistic view of a higher-order problem.
Through its support for delayed clausification and, more generally,
calculus-level formula manipulation, \osup{} enables us to
simulate most successful tableau techniques in a saturating prover
(Sect.~\ref{sec:ho-tech:formulas}). This calculus also supports \emph{Boolean selection
functions}, a mechanism that allows us to choose on which Boolean subterms
to perform inferences first.
We implemented some Boolean selection functions and
evaluated them (Sect.~\ref{sec:ho-tech:bool-select}).

\looseness=-1
The main drawback of both $\lambda$-superposition variants compared with
combinatory superposition is that they rely on rules that enumerate possibly
infinite sets of unifiers. We describe a mechanism that interleaves infinitely
branching inferences with the standard saturation process
(Sect.~\ref{sec:ho-tech:infinite-branching}). The prover retains the same
behavior as before on first-order problems, smoothly scaling with increasing
numbers of higher-order clauses.
%
We also propose heuristics to curb the explosion induced by highly
prolific calculus rules (Sect.~\ref{sec:ho-tech:explosiveness}).

Using first-order backends to finish the proof is common practice in
higher-order reasoning. Since \osup{} coincides with standard
superposition on first-order clauses, invoking backends may
seem redundant; yet Zipperposition is nowhere as efficient as E
\cite{scv-19-e23} or Vampire \cite{lkav-13-vampire}, so invoking a more
efficient backend does make sense. We describe how to achieve a balance
between allowing native higher-order reasoning and
delegating reasoning to a backend (Sect.~\ref{sec:ho-tech:backends}).
%
Finally, we compare Zipperposition~2 with other provers on all monomorphic
higher-order TPTP benchmarks \cite{gs-17-tptp} to perform a more extensive
evaluation than at CASC (Sect.~\ref{sec:ho-tech:comparison}). Our evaluation
corroborates the competition results.

\section{Background and Setting}
\label{sec:ho-tech:background}

We focus on monomorphic higher-order logic, without the axiom of infinity or the
axiom of at least two individuals \cite{bm-14-automation-ho}. However, the
techniques can easily be extended with polymorphism. Indeed, Zipperposition
already supports some of them polymorphically. Further, we use exactly the same
notation for this logic as introduced in Chapter \ref{ch:pre}. Since we are
working with extensions of superposition, we assume the clausal structure
(Sect.~\ref{sec:pre:clauses}). Like in the previous chapter, literals
of clauses can contain arbitrary higher-order terms, including formulas.  


\ourpara{Higher-Order Calculi}
\looseness=-1
We briefly introduced the \osup{} calculus \cite{bbtv-21-full-ho-sup} in
Sect.~\ref{sec:pre:ho-sup-calculi}. It is a refutationally complete inference
system and redundancy criterion for higher-order logic with rank-1 polymorphism,
Hilbert choice, and functional and Boolean extensionality.
% The calculus relies on
% \emph{complete sets of unifiers}
% (\emph{CSUs}). The CSU for $s$ and $t$ with respect to a finite set of variables
% $V$, denoted by $\mathrm{CSU}_V(s,t)$, is a set of unifiers of $s$~and~$t$ such
% that for any unifier $\varrho$ of $s$~and~$t$, there exist substitutions $\sigma
% \in \mathrm{CSU}_V(s,t)$ and $\theta$ such that $\varrho(X) = \sigma(\theta(X))$
% for all variables $X \in V$. The set $V$ is used to distinguish
% important variables from auxiliary variables (which may arise in intermediary
% states of the unification procedure). We usually omit it.
Unlike \lsup{}, this calculus 
does not require axioms defining the logical symbols to cope with formulas.
Instead, it includes Boolean inference rules that mimic
superposition from such axioms into Boolean subterms,
while avoiding the explosion incurred by adding these axioms to the proof state. It
also includes rules that simulate Boolean inferences below applied variables.
Both sets of rules are disabled or replaced with incomplete, ad hoc rules
described in the previus chapter in most configurations
of the CASC portfolio.
A new feature of the calculus that we explore in detail is
the ability to select Boolean subterms
to restrict Boolean and superposition inferences.

In contrast to both $\lambda$-superposition variants, combinatory superposition
does not require enumerating elements of CSU to compute results of inferences.
Instead, it avoids computing CSUs by using a form of first-order unification.
Essentially, it enumerates higher-order terms using rules that instantiate
applied variables with partially applied combinators from the complete
combinator set $\{\cst{S}, \cst{K}, \cst{B}, \cst{C}, \cst{I}\}$. This calculus
is the basis of Vampire~4.5 \cite{br-20-full-sup-w-combs}, which finished
closely behind Satallax 3.4 %~and~3.5
at higher-order division of CASC in 2020.

\looseness=-1
A different, very successful calculus is Satallax's SAT-guided tableaux
\cite{backes-brown-2011}. Satallax was the leading higher-order prover of the
2010s. Its simple and elegant tableaux avoid deep superposition-style rewriting
inferences.
Nevertheless, our working hypothesis for the past years has been
that superposition would likely provide a stronger basis for higher-order
reasoning.
Other competing higher-order calculi include SMT (implemented in CVC4
\cite{brotb-19-ho-smt, cbetal-11-cvc4}) and extensional paramodulation (implemented in Leo-III \cite{sb-21-leo3}).


\ourpara{Zipperposition}
Zipperposition \cite{sc-15-simon-phd,bbtvw-21-sup-lam} is a higher-order
theorem prover that implements both $\lambda$-superposition variants, combinatory
superposition, and other superposition-like calculi.
The prover was conceived as a testbed for rapidly
experimenting with extensions of first-order superposition, but over time it
has assimilated many of E's techniques and heuristics and become quite powerful.
Several of our techniques extend the \emph{given clause procedure}, the standard
saturation procedure described in Sect.~\ref{sec:pre:saturation}.

\ourpara{Experimental Setup}
To assess our techniques, we carried out experiments with Zipperposition~2. We
used two sets of benchmarks:\ all 2851~monomorphic higher-order problems from the
TPTP library \cite{gs-17-tptp} version~7.4.0 (labeled \emph{TPTP})
and 1253 Sledgehammer-generated
monomorphic higher-order problems (labeled \emph{SH}).
Although some techniques support polymorphism, we
uniformly used monomorphic benchmarks.

We fixed a \emph{base} configuration
of Zipperposition parameters as a baseline for all comparisons. This is an
incomplete, pragmatic configuration of \osup{} using heuristics expected to perform
well on a wide range of problems.
%Note that
%we use a different baseline configuration than in our earlier paper \cite{making-ho-work}.
%%% That goes without saying. We use a different calculus! Now clarified in intro. --JB
In each experiment, we varied
the parameters associated with a specific technique to evaluate it. The
experiments were run on StarExec Miami \cite{sst-14-starexec} servers, equipped with
Intel Xeon E5-2620 v4 CPUs clocked at 2.10 GHz. Unless otherwise stated, we used a
CPU time limit of 15~s, roughly the time each configuration is given in the
CASC portfolio mode. The raw evaluation results are available online.%
\footnote{\url{http://doi.org/10.5281/zenodo.5007440}}

