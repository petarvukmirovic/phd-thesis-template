\usepackage{xspace}

\newcommand{\eq}{\approx}
\newcommand{\noteq}{\napprox}

\newcommand\cst[1]{\mathsf{#1}}
\newcommand\imp{\ensuremath{\rightarrow}}
\newcommand\lequiv{\ensuremath{\leftrightarrow}}

\newcommand{\lland}{\mathrel\land}
\newcommand{\llor}{\mathrel\lor}
\newcommand{\newehoh}{\ensuremath{\lambda}E}

\newcommand{\tuple}[2]{\overline{#1}_{#2}}
\newcommand{\tuplen}[1]{\overline{#1}_{n}}

\newcommand{\lam}[2]{\ensuremath{\lambda #1.\> #2}}
\newcommand{\lamx}[1]{\lam{x}{#1}}

\newcommand{\ifalse}{\pmb\bot}
\newcommand{\itrue}{\pmb\top}
\newcommand{\inot}{\pmb{\neg\,}}
\newcommand{\iand}{\pmb\land}
\newcommand{\ior}{\pmb\lor}
\newcommand{\iimplies}{\pmb\rightarrow}
\newcommand{\iequiv}{\pmb\leftrightarrow}
\newcommand{\iforall}{\pmb\forall}
\newcommand{\iexists}{\pmb\exists}
\newcommand{\ieq}{\pmb\approx}
\newcommand{\ineq}{\pmb{\not\approx}}
\newcommand{\equi}{\leftrightarrow^*_{\alpha\beta\eta}}


\newcommand{\neglit}[1]{\ensuremath{#1 \noteq \itrue}}
\newcommand{\poslit}[1]{\ensuremath{#1 \eq \itrue}}

\newcommand{\substterm}[2]{\ensuremath{#1(#2)}}
\newcommand{\sigmaterm}[1]{\ensuremath{\substterm{\sigma}{#1}}}

\newcommand{\substcl}[2]{\ensuremath{#2#1}}
\newcommand{\sigmacl}[1]{\ensuremath{\substcl{\sigma}{#1}}}

\newcommand\unif{\mathrel{\smash{\stackrel{\lower.1ex\hbox{\ensuremath{\scriptscriptstyle ?}}}{=}}}}
%\newcommand\UNIF{=^?}



\newcommand\infname[1]{\textsc{#1}}
% Inference rule
\newcommand{\namedinference}[3]{\prftree[r]{\relax{\infname{#1}}}{\strut#2}{\strut#3}}
\newcommand{\inference}[2]{\namedinference{}{\strut#1}{\strut#2}}

% Simplification rule
\newcommand{\namedsimp}[3]{\prftree[d][r]{\relax{\infname{#1}}}{\strut#2}{\strut#3}}
\newcommand{\simp}[2]{\namedinference{}{\strut#1}{\strut#2}}
\newcommand{\ourmodel}{\ensuremath{\mathscr{J}}}
\newcommand{\NumberOK}[1]{#1}

\newcommand{\lfhol}[0]{$\lambda$fHOL}
\newcommand{\appvar}[0]{\ensuremath{\mathsf{@}}}

\newcommand{\ourpara}[1]{\paragraph{#1}}

\newcommand\Unifarrow{\Longrightarrow}
\newcommand\Matcharrow{\Longrightarrow}
\newcommand\Pdtarrow{\leadsto}
\newcommand\Matchiiarrow{\hooklongrightarrow}
\newcommand\Unifier{\mathcalx{U}}
\newcommand\Var{\mathcalx{V}\!\mathit{ar}} %% TYPESETTING: hack
\newcommand\Term{\mathcalx{T}\kern-.4ex\mathit{erm}} %% TYPESETTING: hack
\newcommand\Gfpf{\mathcalx{G}\mathit{fpf}}
\newcommand\GfpfRTL{\Gfpf'}
\newcommand\Fp{\mathcalx{F}\kern-.3ex\mathit{p}} %% TYPESETTING: hack
\newcommand\FpRTL{\Fp'}

\newtheorem{theorem}{Theorem}{\bfseries}{\slshape}
\newtheorem{corollary}[theorem]{Corollary}{\bfseries}{\slshape}
\newtheorem{lemma}[theorem]{Lemma}{\bfseries}{\slshape}
% \newtheorem*{proof}{Proof}{\itshape}{\rmfamily}

\newcommand\MyFunction[2]{\textbf{function} \textsc{#1}(#2) \textbf{is} \\}
\newcommand\MyProcedure[2]{\textbf{procedure} \textsc{#1}(#2) \textbf{is} \\}
\newcommand\MyIf[1]{\textbf{if} #1 \textbf{then} \\}
\newcommand\MyIfWoThen[1]{\textbf{if} #1 \\}
\newcommand\MyThen[1]{\phantom{\textbf{if}} \quad #1 \textbf{then} \\}
\newcommand\MyElse{\textbf{else} \\}
\newcommand\MyElsIf[1]{\textbf{else} \textbf{if} #1 \textbf{then} \\}
\newcommand\MyForTo[2]{\textbf{for} #1 \textbf{to} #2 \textbf{do} \\}
\newcommand\MyDo{\textbf{do} \\}
\newcommand\MyForever{\textbf{forever} \textbf{do} \\}
\newcommand\MyWhileOfDo[1]{\textbf{while} #1}
\newcommand\MyForDownto[2]{\textbf{for} #1 \textbf{downto} #2 \textbf{do} \\}
\newcommand\MyWhile[1]{\textbf{while} #1 \textbf{do} \\}
\newcommand\MyReturn{\textbf{return} }

\newcommand\q{\noindent\hbox{}\quad}
\newcommand\qq{\q\q}
\newcommand\qqq{\qq\q}
\newcommand\qqqq{\qqq\q}
\newcommand\qqqqq{\qqqq\q}
\newcommand\qqqqqq{\qqqqq\q}
\newcommand\qqqqqqq{\qqqqqq\q}
\newcommand\qqqqqqqq{\qqqqqqq\q}
\newcommand\qqqqqqqqq{\qqqqqqqq\q}

\newenvironment{quotex}
 {\list{}{\rightmargin0pt}%
  \item\relax}
 {\endlist}

